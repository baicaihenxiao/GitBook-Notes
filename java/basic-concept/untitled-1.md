# ä¸€ä¸ªHashMapè·Ÿé¢è¯•å®˜æ‰¯äº†åŠä¸ªå°æ—¶

{% embed url="https://mp.weixin.qq.com/s/t7ut\_ah1F7duQyuw514XMw" %}

\*\*\*\*

**å‰è¨€**

HashMapåº”è¯¥ç®—æ˜¯Javaåç«¯å·¥ç¨‹å¸ˆé¢è¯•çš„å¿…é—®é¢˜ï¼Œå› ä¸ºå…¶ä¸­çš„çŸ¥è¯†ç‚¹å¤ªå¤šï¼Œå¾ˆé€‚åˆç”¨æ¥è€ƒå¯Ÿé¢è¯•è€…çš„JavaåŸºç¡€ã€‚

## **å¼€åœº**

**é¢è¯•å®˜**: ä½ å…ˆè‡ªæˆ‘ä»‹ç»ä¸€ä¸‹å§ï¼

**å®‰çªæ‹‰**: æˆ‘æ˜¯å®‰çªæ‹‰ï¼Œè‰ä¸›ä¸‰å©Šä¹‹ä¸€ï¼Œæœ€å¼ºä¸­å•ï¼ˆé’Ÿé¦—ä¸æœï¼‰ï¼å“¦ï¼Œä¸å¯¹ï¼Œä¸²åœºäº†ï¼Œæˆ‘æ˜¯\*\*ï¼Œç›®å‰åœ¨--å…¬å¸åš--ç³»ç»Ÿå¼€å‘ã€‚

**é¢è¯•å®˜**: çœ‹ä½ ç®€å†ä¸Šå†™ç†Ÿæ‚‰Javaé›†åˆï¼ŒHashMapç”¨è¿‡çš„å§ï¼Ÿ

**å®‰çªæ‹‰**: ç”¨è¿‡çš„ã€‚\(è¿˜æ˜¯ç†Ÿæ‚‰çš„å‘³é“\)

**é¢è¯•å®˜**: é‚£ä½ è·Ÿæˆ‘è®²è®²HashMapçš„å†…éƒ¨æ•°æ®ç»“æ„ï¼Ÿ

**å®‰çªæ‹‰**: ç›®å‰æˆ‘ç”¨çš„æ˜¯JDK1.8ç‰ˆæœ¬çš„ï¼Œå†…éƒ¨ä½¿ç”¨æ•°ç»„ + é“¾è¡¨ / çº¢é»‘æ ‘ï¼›

**å®‰çªæ‹‰**: æ–¹ä¾¿æˆ‘ç»™æ‚¨ç”»ä¸ªæ•°æ®ç»“æ„å›¾å§ï¼š

**é¢è¯•å®˜**: é‚£ä½ æ¸…æ¥šHashMapçš„æ•°æ®æ’å…¥åŸç†å—ï¼Ÿ

**å®‰çªæ‹‰**: å‘ƒ\[åšæ²‰æ€çŠ¶\]ã€‚æˆ‘è§‰å¾—è¿˜æ˜¯åº”è¯¥ç”»ä¸ªå›¾æ¯”è¾ƒæ¸…æ¥šï¼Œå¦‚ä¸‹ï¼š

1. åˆ¤æ–­æ•°ç»„æ˜¯å¦ä¸ºç©ºï¼Œä¸ºç©ºè¿›è¡Œåˆå§‹åŒ–;
2. ä¸ä¸ºç©ºï¼Œè®¡ç®— k çš„ hash å€¼ï¼Œé€šè¿‡ `(n - 1) & hash`è®¡ç®—åº”å½“å­˜æ”¾åœ¨æ•°ç»„ä¸­çš„ä¸‹æ ‡ index ;
3. æŸ¥çœ‹ table\[index\] æ˜¯å¦å­˜åœ¨æ•°æ®ï¼Œæ²¡æœ‰æ•°æ®å°±æ„é€ ä¸€ä¸ªNodeèŠ‚ç‚¹å­˜æ”¾åœ¨ table\[index\] ä¸­ï¼›
4. å­˜åœ¨æ•°æ®ï¼Œè¯´æ˜å‘ç”Ÿäº†hashå†²çª, ç»§ç»­åˆ¤æ–­keyæ˜¯å¦ç›¸ç­‰ï¼Œç›¸ç­‰ï¼Œç”¨æ–°çš„valueæ›¿æ¢åŸæ•°æ®\(onlyIfAbsentä¸ºfalse\)ï¼›
5. å¦‚æœä¸ç›¸ç­‰ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹ç±»å‹æ˜¯ä¸æ˜¯æ ‘å‹èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯æ ‘å‹èŠ‚ç‚¹ï¼Œåˆ›å»ºæ ‘å‹èŠ‚ç‚¹æ’å…¥çº¢é»‘æ ‘ä¸­ï¼›
6. å¦‚æœä¸æ˜¯æ ‘å‹èŠ‚ç‚¹ï¼Œåˆ›å»ºæ™®é€šNodeåŠ å…¥é“¾è¡¨ä¸­ï¼›åˆ¤æ–­é“¾è¡¨é•¿åº¦æ˜¯å¦å¤§äº 8ï¼Œ å¤§äºçš„è¯é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼›
7. æ’å…¥å®Œæˆä¹‹ååˆ¤æ–­å½“å‰èŠ‚ç‚¹æ•°æ˜¯å¦å¤§äºé˜ˆå€¼ï¼Œå¦‚æœå¤§äºå¼€å§‹æ‰©å®¹ä¸ºåŸæ•°ç»„çš„äºŒå€ã€‚

**é¢è¯•å®˜**: åˆšæ‰ä½ æåˆ°HashMapçš„åˆå§‹åŒ–ï¼Œé‚£HashMapæ€ä¹ˆè®¾å®šåˆå§‹å®¹é‡å¤§å°çš„å—ï¼Ÿ

**å®‰çªæ‹‰**: \[è¿™ä¹Ÿç®—é—®é¢˜ï¼Ÿ?\] ä¸€èˆ¬å¦‚æœ`new HashMap()` ä¸ä¼ å€¼ï¼Œé»˜è®¤å¤§å°æ˜¯16ï¼Œè´Ÿè½½å› å­æ˜¯0.75ï¼Œ å¦‚æœè‡ªå·±ä¼ å…¥åˆå§‹å¤§å°kï¼Œåˆå§‹åŒ–å¤§å°ä¸º å¤§äºkçš„ 2çš„æ•´æ•°æ¬¡æ–¹ï¼Œä¾‹å¦‚å¦‚æœä¼ 10ï¼Œå¤§å°ä¸º16ã€‚ï¼ˆè¡¥å……è¯´æ˜:å®ç°ä»£ç å¦‚ä¸‹ï¼‰

* * * * * * * * * 
```text
static final int tableSizeFor(int cap) {  int n = cap - 1;  n |= n >>> 1;  n |= n >>> 2;  n |= n >>> 4;  n |= n >>> 8;  n |= n >>> 16;  return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}
```

> è¡¥å……è¯´æ˜ï¼šä¸‹å›¾æ˜¯è¯¦ç»†è¿‡ç¨‹ï¼Œç®—æ³•å°±æ˜¯è®©åˆå§‹äºŒè¿›åˆ¶åˆ†åˆ«å³ç§»1ï¼Œ2ï¼Œ4ï¼Œ8ï¼Œ16ä½ï¼Œä¸è‡ªå·±å¼‚æˆ–ï¼ŒæŠŠé«˜ä½ç¬¬ä¸€ä¸ªä¸º1çš„æ•°é€šè¿‡ä¸æ–­å³ç§»ï¼ŒæŠŠé«˜ä½ä¸º1çš„åé¢å…¨å˜ä¸º1ï¼Œ111111 + 1 = 1000000  = ï¼ˆç¬¦åˆå¤§äº50å¹¶ä¸”æ˜¯2çš„æ•´æ•°æ¬¡å¹‚ ï¼‰

**é¢è¯•å®˜**:  ä½ æåˆ°hashå‡½æ•°ï¼Œä½ çŸ¥é“HashMapçš„å“ˆå¸Œå‡½æ•°æ€ä¹ˆè®¾è®¡çš„å—ï¼Ÿ**å®‰çªæ‹‰**:  \[é—®çš„è¿˜æŒºç»†\] hashå‡½æ•°æ˜¯å…ˆæ‹¿åˆ°é€šè¿‡key çš„hashcodeï¼Œæ˜¯32ä½çš„intå€¼ï¼Œç„¶åè®©hashcodeçš„é«˜16ä½å’Œä½16ä½è¿›è¡Œå¼‚æˆ–æ“ä½œã€‚**é¢è¯•å®˜**:  é‚£ä½ çŸ¥é“ä¸ºä»€ä¹ˆè¿™ä¹ˆè®¾è®¡å—ï¼Ÿ**å®‰çªæ‹‰**:  \[è¿™ä¹Ÿè¦é—®\]ï¼Œè¿™ä¸ªä¹Ÿå«æ‰°åŠ¨å‡½æ•°ï¼Œè¿™ä¹ˆè®¾è®¡æœ‰äºŒç‚¹åŸå› ï¼š

1. ä¸€å®šè¦å°½å¯èƒ½é™ä½hashç¢°æ’ï¼Œè¶Šåˆ†æ•£è¶Šå¥½ï¼›
2. ç®—æ³•ä¸€å®šè¦å°½å¯èƒ½é«˜æ•ˆï¼Œå› ä¸ºè¿™æ˜¯é«˜é¢‘æ“ä½œ, å› æ­¤é‡‡ç”¨ä½è¿ç®—ï¼›

**é¢è¯•å®˜**:  ä¸ºä»€ä¹ˆé‡‡ç”¨hashcodeçš„é«˜16ä½å’Œä½16ä½å¼‚æˆ–èƒ½é™ä½hashç¢°æ’ï¼Ÿhashå‡½æ•°èƒ½ä¸èƒ½ç›´æ¥ç”¨keyçš„hashcodeï¼Ÿ\[è¿™é—®é¢˜æœ‰ç‚¹åˆé’»\], å®‰çªæ‹‰å·®ç‚¹åŸåœ°ğŸ’¥äº†ï¼Œæ¨ä¸å¾—å‡ºbiubiubiu äºŒä¸€ä¸‰è¿æ‹›ã€‚**å®‰çªæ‹‰**:  å› ä¸º key.hashCode\(\) å‡½æ•°è°ƒç”¨çš„æ˜¯keyé”®å€¼ç±»å‹è‡ªå¸¦çš„å“ˆå¸Œå‡½æ•°ï¼Œè¿”å›intå‹æ•£åˆ—å€¼ã€‚intå€¼èŒƒå›´ä¸º\*\*-2147483648~2147483647\*\*ï¼Œå‰ååŠ èµ·æ¥å¤§æ¦‚40äº¿çš„æ˜ å°„ç©ºé—´ã€‚åªè¦å“ˆå¸Œå‡½æ•°æ˜ å°„å¾—æ¯”è¾ƒå‡åŒ€æ¾æ•£ï¼Œä¸€èˆ¬åº”ç”¨æ˜¯å¾ˆéš¾å‡ºç°ç¢°æ’çš„ã€‚ä½†é—®é¢˜æ˜¯ä¸€ä¸ª40äº¿é•¿åº¦çš„æ•°ç»„ï¼Œå†…å­˜æ˜¯æ”¾ä¸ä¸‹çš„ã€‚ä½ æƒ³ï¼Œå¦‚æœHashMapæ•°ç»„çš„åˆå§‹å¤§å°æ‰16ï¼Œç”¨ä¹‹å‰éœ€è¦å¯¹æ•°ç»„çš„é•¿åº¦å–æ¨¡è¿ç®—ï¼Œå¾—åˆ°çš„ä½™æ•°æ‰èƒ½ç”¨æ¥è®¿é—®æ•°ç»„ä¸‹æ ‡ã€‚æºç ä¸­æ¨¡è¿ç®—å°±æ˜¯æŠŠæ•£åˆ—å€¼å’Œæ•°ç»„é•¿åº¦-1åšä¸€ä¸ª"ä¸"æ“ä½œï¼Œä½è¿ç®—æ¯”%è¿ç®—è¦å¿«ã€‚

* * * * * 
```text
bucketIndex = indexFor(hash, table.length);
static int indexFor(int h, int length) {return h & (length-1);}
```

é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œè¿™ä¹Ÿæ­£å¥½è§£é‡Šäº†ä¸ºä»€ä¹ˆHashMapçš„æ•°ç»„é•¿åº¦è¦å–2çš„æ•´æ•°å¹‚ã€‚å› ä¸ºè¿™æ ·ï¼ˆæ•°ç»„é•¿åº¦-1ï¼‰æ­£å¥½ç›¸å½“äºä¸€ä¸ªâ€œä½ä½æ©ç â€ã€‚â€œä¸â€æ“ä½œçš„ç»“æœå°±æ˜¯æ•£åˆ—å€¼çš„é«˜ä½å…¨éƒ¨å½’é›¶ï¼Œåªä¿ç•™ä½ä½å€¼ï¼Œç”¨æ¥åšæ•°ç»„ä¸‹æ ‡è®¿é—®ã€‚ä»¥åˆå§‹é•¿åº¦16ä¸ºä¾‹ï¼Œ16-1=15ã€‚2è¿›åˆ¶è¡¨ç¤ºæ˜¯00000000 00000000 00001111ã€‚å’ŒæŸæ•£åˆ—å€¼åšâ€œä¸â€æ“ä½œå¦‚ä¸‹ï¼Œç»“æœå°±æ˜¯æˆªå–äº†æœ€ä½çš„å››ä½å€¼ã€‚

```text
  10100101 11000100 00100101& 00000000 00000000 00001111----------------------------------  00000000 00000000 00000101    //é«˜ä½å…¨éƒ¨å½’é›¶ï¼Œåªä¿ç•™æœ«å››ä½
```

ä½†è¿™æ—¶å€™é—®é¢˜å°±æ¥äº†ï¼Œè¿™æ ·å°±ç®—æˆ‘çš„æ•£åˆ—å€¼åˆ†å¸ƒå†æ¾æ•£ï¼Œè¦æ˜¯åªå–æœ€åå‡ ä½çš„è¯ï¼Œç¢°æ’ä¹Ÿä¼šå¾ˆä¸¥é‡ã€‚æ›´è¦å‘½çš„æ˜¯å¦‚æœæ•£åˆ—æœ¬èº«åšå¾—ä¸å¥½ï¼Œåˆ†å¸ƒä¸Šæˆç­‰å·®æ•°åˆ—çš„æ¼æ´ï¼Œå¦‚æœæ­£å¥½è®©æœ€åå‡ ä¸ªä½ä½å‘ˆç°è§„å¾‹æ€§é‡å¤ï¼Œå°±æ— æ¯”è›‹ç–¼ã€‚è¿™æ—¶å€™ hash å‡½æ•°ï¼ˆâ€œæ‰°åŠ¨å‡½æ•°â€ï¼‰çš„ä»·å€¼å°±ä½“ç°å‡ºæ¥äº†ï¼Œè¯´åˆ°è¿™é‡Œå¤§å®¶åº”è¯¥çŒœå‡ºæ¥äº†ã€‚çœ‹ä¸‹é¢è¿™ä¸ªå›¾ï¼Œå³ä½ç§»16ä½ï¼Œæ­£å¥½æ˜¯32bitçš„ä¸€åŠï¼Œè‡ªå·±çš„é«˜åŠåŒºå’Œä½åŠåŒºåšå¼‚æˆ–ï¼Œå°±æ˜¯ä¸ºäº†æ··åˆåŸå§‹å“ˆå¸Œç çš„é«˜ä½å’Œä½ä½ï¼Œä»¥æ­¤æ¥åŠ å¤§ä½ä½çš„éšæœºæ€§ã€‚è€Œä¸”æ··åˆåçš„ä½ä½æºæ‚äº†é«˜ä½çš„éƒ¨åˆ†ç‰¹å¾ï¼Œè¿™æ ·é«˜ä½çš„ä¿¡æ¯ä¹Ÿè¢«å˜ç›¸ä¿ç•™ä¸‹æ¥ã€‚æœ€åæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹Peter Lawleyçš„ä¸€ç¯‡ä¸“æ æ–‡ç« ã€ŠAn introduction to optimising a hashing strategyã€‹é‡Œçš„çš„ä¸€ä¸ªå®éªŒï¼šä»–éšæœºé€‰å–äº†352ä¸ªå­—ç¬¦ä¸²ï¼Œåœ¨ä»–ä»¬æ•£åˆ—å€¼å®Œå…¨æ²¡æœ‰å†²çªçš„å‰æä¸‹ï¼Œå¯¹å®ƒä»¬åšä½ä½æ©ç ï¼Œå–æ•°ç»„ä¸‹æ ‡ã€‚ç»“æœæ˜¾ç¤ºï¼Œå½“HashMapæ•°ç»„é•¿åº¦ä¸º512çš„æ—¶å€™ï¼ˆï¼‰ï¼Œä¹Ÿå°±æ˜¯ç”¨æ©ç å–ä½9ä½çš„æ—¶å€™ï¼Œåœ¨æ²¡æœ‰æ‰°åŠ¨å‡½æ•°çš„æƒ…å†µä¸‹ï¼Œå‘ç”Ÿäº†103æ¬¡ç¢°æ’ï¼Œæ¥è¿‘30%ã€‚è€Œåœ¨ä½¿ç”¨äº†æ‰°åŠ¨å‡½æ•°ä¹‹ååªæœ‰92æ¬¡ç¢°æ’ã€‚ç¢°æ’å‡å°‘äº†å°†è¿‘10%ã€‚çœ‹æ¥æ‰°åŠ¨å‡½æ•°ç¡®å®è¿˜æ˜¯æœ‰åŠŸæ•ˆçš„ã€‚å¦å¤–Java1.8ç›¸æ¯”1.7åšäº†è°ƒæ•´ï¼Œ1.7åšäº†å››æ¬¡ç§»ä½å’Œå››æ¬¡å¼‚æˆ–ï¼Œä½†æ˜æ˜¾Java 8è§‰å¾—æ‰°åŠ¨åšä¸€æ¬¡å°±å¤Ÿäº†ï¼Œåš4æ¬¡çš„è¯ï¼Œå¤šäº†å¯èƒ½è¾¹é™…æ•ˆç”¨ä¹Ÿä¸å¤§ï¼Œæ‰€è°“ä¸ºäº†æ•ˆç‡è€ƒè™‘å°±æ”¹æˆä¸€æ¬¡äº†ã€‚ä¸‹é¢æ˜¯1.7çš„hashä»£ç ï¼š

* * * * 
```text
static int hash(int h) {    h ^= (h >>> 20) ^ (h >>> 12);    return h ^ (h >>> 7) ^ (h >>> 4);}
```

**é¢è¯•å®˜**:  çœ‹æ¥åšè¿‡åŠŸè¯¾ï¼Œæœ‰ç‚¹æ–™å•Šï¼æ˜¯ä¸æ˜¯å·å·çœ‹äº†**å®‰çªæ‹‰çš„åšå®¢**å…¬ä¼—å·, ä½ åˆšåˆšè¯´åˆ°1.8å¯¹hashå‡½æ•°åšäº†ä¼˜åŒ–ï¼Œ1.8è¿˜æœ‰åˆ«çš„ä¼˜åŒ–å—ï¼Ÿ**å®‰çªæ‹‰**: 1.8è¿˜æœ‰ä¸‰ç‚¹ä¸»è¦çš„ä¼˜åŒ–ï¼š

1. æ•°ç»„+é“¾è¡¨æ”¹æˆäº†æ•°ç»„+é“¾è¡¨æˆ–çº¢é»‘æ ‘ï¼›
2. é“¾è¡¨çš„æ’å…¥æ–¹å¼ä»å¤´æ’æ³•æ”¹æˆäº†å°¾æ’æ³•ï¼Œç®€å•è¯´å°±æ˜¯æ’å…¥æ—¶ï¼Œå¦‚æœæ•°ç»„ä½ç½®ä¸Šå·²ç»æœ‰å…ƒç´ ï¼Œ1.7å°†æ–°å…ƒç´ æ”¾åˆ°æ•°ç»„ä¸­ï¼ŒåŸå§‹èŠ‚ç‚¹ä½œä¸ºæ–°èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹ï¼Œ1.8éå†é“¾è¡¨ï¼Œå°†å…ƒç´ æ”¾ç½®åˆ°é“¾è¡¨çš„æœ€åï¼›
3. æ‰©å®¹çš„æ—¶å€™1.7éœ€è¦å¯¹åŸæ•°ç»„ä¸­çš„å…ƒç´ è¿›è¡Œé‡æ–°hashå®šä½åœ¨æ–°æ•°ç»„çš„ä½ç½®ï¼Œ1.8é‡‡ç”¨æ›´ç®€å•çš„åˆ¤æ–­é€»è¾‘ï¼Œä½ç½®ä¸å˜æˆ–ç´¢å¼•+æ—§å®¹é‡å¤§å°ï¼›
4. åœ¨æ’å…¥æ—¶ï¼Œ1.7å…ˆåˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹ï¼Œå†æ’å…¥ï¼Œ1.8å…ˆè¿›è¡Œæ’å…¥ï¼Œæ’å…¥å®Œæˆå†åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰©å®¹ï¼›

**é¢è¯•å®˜**:  ä½ åˆ†åˆ«è·Ÿæˆ‘è®²è®²ä¸ºä»€ä¹ˆè¦åšè¿™å‡ ç‚¹ä¼˜åŒ–ï¼›**å®‰çªæ‹‰**:  ã€å’³å’³ï¼Œæœç„¶æ˜¯è¿ç¯ç‚®ã€‘

1. é˜²æ­¢å‘ç”Ÿhashå†²çªï¼Œé“¾è¡¨é•¿åº¦è¿‡é•¿ï¼Œå°†æ—¶é—´å¤æ‚åº¦ç”±`O(n)`é™ä¸º`O(logn)`;
2. å› ä¸º1.7å¤´æ’æ³•æ‰©å®¹æ—¶ï¼Œå¤´æ’æ³•ä¼šä½¿é“¾è¡¨å‘ç”Ÿåè½¬ï¼Œå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¼šäº§ç”Ÿç¯ï¼›Açº¿ç¨‹åœ¨æ’å…¥èŠ‚ç‚¹Bï¼ŒBçº¿ç¨‹ä¹Ÿåœ¨æ’å…¥ï¼Œé‡åˆ°å®¹é‡ä¸å¤Ÿå¼€å§‹æ‰©å®¹ï¼Œé‡æ–°hashï¼Œæ”¾ç½®å…ƒç´ ï¼Œé‡‡ç”¨å¤´æ’æ³•ï¼Œåéå†åˆ°çš„BèŠ‚ç‚¹æ”¾å…¥äº†å¤´éƒ¨ï¼Œè¿™æ ·å½¢æˆäº†ç¯ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

1.7çš„æ‰©å®¹è°ƒç”¨transferä»£ç ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

* * * * * * * * * * * * * * * * 
```text
void transfer(Entry[] newTable, boolean rehash) {  int newCapacity = newTable.length;  for (Entry e : table) {    while(null != e) {      Entry next = e.next;      if (rehash) {        e.hash = null == e.key ? 0 : hash(e.key);      }      int i = indexFor(e.hash, newCapacity);      e.next = newTable[i]; //Açº¿ç¨‹å¦‚æœæ‰§è¡Œåˆ°è¿™ä¸€è¡ŒæŒ‚èµ·ï¼ŒBçº¿ç¨‹å¼€å§‹è¿›è¡Œæ‰©å®¹      newTable[i] = e;      e = next;    }  }}
```

1. æ‰©å®¹çš„æ—¶å€™ä¸ºä»€ä¹ˆ1.8 ä¸ç”¨é‡æ–°hashå°±å¯ä»¥ç›´æ¥å®šä½åŸèŠ‚ç‚¹åœ¨æ–°æ•°æ®çš„ä½ç½®å‘¢?è¿™æ˜¯ç”±äºæ‰©å®¹æ˜¯æ‰©å¤§ä¸ºåŸæ•°ç»„å¤§å°çš„2å€ï¼Œç”¨äºè®¡ç®—æ•°ç»„ä½ç½®çš„æ©ç ä»…ä»…åªæ˜¯é«˜ä½å¤šäº†ä¸€ä¸ª1ï¼Œä¸¾ä¸ªä¾‹å­ï¼š

   æ‰©å®¹å‰é•¿åº¦ä¸º16ï¼Œç”¨äºè®¡ç®— \(n-1\) & hash çš„äºŒè¿›åˆ¶n - 1ä¸º0000 1111ï¼Œ       æ‰©å®¹åä¸º32åçš„äºŒè¿›åˆ¶å°±é«˜ä½å¤šäº†1ï¼Œ============&gt;ä¸º0001 1111ã€‚  


1. å› ä¸ºæ˜¯& è¿ç®—ï¼Œ1å’Œä»»ä½•æ•° & éƒ½æ˜¯å®ƒæœ¬èº«ï¼Œé‚£å°±åˆ†äºŒç§æƒ…å†µï¼Œå¦‚ä¸‹å›¾ï¼šåŸæ•°æ®hashcodeé«˜ä½ç¬¬4ä½ä¸º0å’Œé«˜ä½ä¸º1çš„æƒ…å†µï¼›ç¬¬å››ä½é«˜ä½ä¸º0ï¼Œé‡æ–°hashæ•°å€¼ä¸å˜ï¼Œç¬¬å››ä½ä¸º1ï¼Œé‡æ–°hashæ•°å€¼æ¯”åŸæ¥å¤§16ï¼ˆæ—§æ•°ç»„çš„å®¹é‡ï¼‰

**é¢è¯•å®˜**:  é‚£HashMapæ˜¯çº¿ç¨‹å®‰å…¨çš„å—ï¼Ÿ**å®‰çªæ‹‰**:  ä¸æ˜¯ï¼Œåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œ1.7 ä¼šäº§ç”Ÿæ­»å¾ªç¯ã€æ•°æ®ä¸¢å¤±ã€æ•°æ®è¦†ç›–çš„é—®é¢˜ï¼Œ1.8 ä¸­ä¼šæœ‰æ•°æ®è¦†ç›–çš„é—®é¢˜ã€‚ä»¥1.8ä¸ºä¾‹ï¼Œå½“Açº¿ç¨‹æ‰§è¡Œåˆ°ä¸‹é¢ä»£ç ç¬¬6è¡Œåˆ¤æ–­indexä½ç½®ä¸ºç©ºåæ­£å¥½æŒ‚èµ·ï¼ŒBçº¿ç¨‹å¼€å§‹æ‰§è¡Œç¬¬7 è¡Œï¼Œå¾€indexä½ç½®çš„å†™å…¥èŠ‚ç‚¹æ•°æ®ï¼Œè¿™æ—¶Açº¿ç¨‹æ¢å¤ç°åœºï¼Œæ‰§è¡Œèµ‹å€¼æ“ä½œï¼Œå°±æŠŠAçº¿ç¨‹çš„æ•°æ®ç»™è¦†ç›–äº†ï¼›è¿˜æœ‰ç¬¬38è¡Œ++sizeè¿™ä¸ªåœ°æ–¹ä¹Ÿä¼šé€ æˆå¤šçº¿ç¨‹åŒæ—¶æ‰©å®¹ç­‰é—®é¢˜ã€‚

* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
```text
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {  Node[] tab; Node p; int n, i;  if ((tab = table) == null || (n = tab.length) == 0)    n = (tab = resize()).length;  if ((p = tab[i = (n - 1) & hash]) == null)  //å¤šçº¿ç¨‹æ‰§è¡Œåˆ°è¿™é‡Œ    tab[i] = newNode(hash, key, value, null);  else {    Node e; K k;    if (p.hash == hash &&        ((k = p.key) == key || (key != null && key.equals(k))))      e = p;    else if (p instanceof TreeNode)      e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value);    else {      for (int binCount = 0; ; ++binCount) {        if ((e = p.next) == null) {          p.next = newNode(hash, key, value, null);          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st            treeifyBin(tab, hash);          break;        }        if (e.hash == hash &&            ((k = e.key) == key || (key != null && key.equals(k))))          break;        p = e;      }    }    if (e != null) { // existing mapping for key      V oldValue = e.value;      if (!onlyIfAbsent || oldValue == null)        e.value = value;      afterNodeAccess(e);      return oldValue;    }  }  ++modCount;  if (++size > threshold) // å¤šä¸ªçº¿ç¨‹èµ°åˆ°è¿™ï¼Œå¯èƒ½é‡å¤resize()    resize();  afterNodeInsertion(evict);  return null;}
```

**é¢è¯•å®˜**:  é‚£ä½ å¹³å¸¸æ€ä¹ˆè§£å†³è¿™ä¸ªçº¿ç¨‹ä¸å®‰å…¨çš„é—®é¢˜ï¼Ÿ**å®‰çªæ‹‰**:  Javaä¸­æœ‰HashTableã€Collections.synchronizedMapã€ä»¥åŠConcurrentHashMapå¯ä»¥å®ç°çº¿ç¨‹å®‰å…¨çš„Mapã€‚

1. HashTableæ˜¯ç›´æ¥åœ¨æ“ä½œæ–¹æ³•ä¸ŠåŠ synchronizedå…³é”®å­—ï¼Œé”ä½æ•´ä¸ªæ•°ç»„ï¼Œç²’åº¦æ¯”è¾ƒå¤§ï¼›
2. Collections.synchronizedMapæ˜¯ä½¿ç”¨Collectionsé›†åˆå·¥å…·çš„å†…éƒ¨ç±»ï¼Œé€šè¿‡ä¼ å…¥Mapå°è£…å‡ºä¸€ä¸ªSynchronizedMapå¯¹è±¡ï¼Œå†…éƒ¨å®šä¹‰äº†ä¸€ä¸ªå¯¹è±¡é”ï¼Œæ–¹æ³•å†…é€šè¿‡å¯¹è±¡é”å®ç°ï¼›
3. ConcurrentHashMapä½¿ç”¨åˆ†æ®µé”ï¼Œé™ä½äº†é”ç²’åº¦ï¼Œè®©å¹¶å‘åº¦å¤§å¤§æé«˜ã€‚

**é¢è¯•å®˜**:  é‚£ä½ çŸ¥é“ConcurrentHashMapçš„åˆ†æ®µé”çš„å®ç°åŸç†å—ï¼Ÿ**å®‰çªæ‹‰**:  ã€å¤©å•¦æ’¸! ä¿„ç½—æ–¯å¥—å¨ƒï¼Œä¸€ä¸ªå¥—ä¸€ä¸ªã€‘ConcurrentHashMapæˆå‘˜å˜é‡ä½¿ç”¨volatile ä¿®é¥°ï¼Œå…é™¤äº†æŒ‡ä»¤é‡æ’åºï¼ŒåŒæ—¶ä¿è¯å†…å­˜å¯è§æ€§ï¼Œå¦å¤–ä½¿ç”¨CASæ“ä½œå’Œsynchronizedç»“åˆå®ç°èµ‹å€¼æ“ä½œï¼Œå¤šçº¿ç¨‹æ“ä½œåªä¼šé”ä½å½“å‰æ“ä½œç´¢å¼•çš„èŠ‚ç‚¹ã€‚å¦‚ä¸‹å›¾ï¼Œçº¿ç¨‹Aé”ä½AèŠ‚ç‚¹æ‰€åœ¨é“¾è¡¨ï¼Œçº¿ç¨‹Bé”ä½BèŠ‚ç‚¹æ‰€åœ¨é“¾è¡¨ï¼Œæ“ä½œäº’ä¸å¹²æ¶‰ã€‚**é¢è¯•å®˜**:  ä½ å‰é¢æåˆ°é“¾è¡¨è½¬çº¢é»‘æ ‘æ˜¯é“¾è¡¨é•¿åº¦è¾¾åˆ°é˜ˆå€¼ï¼Œè¿™ä¸ªé˜ˆå€¼æ˜¯å¤šå°‘ï¼Ÿ**å®‰çªæ‹‰**:  é˜ˆå€¼æ˜¯8ï¼Œçº¢é»‘æ ‘è½¬é“¾è¡¨é˜ˆå€¼ä¸º6**é¢è¯•å®˜**:  ä¸ºä»€ä¹ˆæ˜¯8ï¼Œä¸æ˜¯16ï¼Œ32ç”šè‡³æ˜¯7 ï¼Ÿåˆä¸ºä»€ä¹ˆçº¢é»‘æ ‘è½¬é“¾è¡¨çš„é˜ˆå€¼æ˜¯6ï¼Œä¸æ˜¯8äº†å‘¢ï¼Ÿ**å®‰çªæ‹‰**: ã€ä½ å»é—®ä½œè€…å•Šï¼å¤©å•¦æ’¸ï¼Œbiubiubiu çœŸæƒ³213è¿æ‹›ã€‘å› ä¸ºä½œè€…å°±è¿™ä¹ˆè®¾è®¡çš„ï¼Œå“¦ï¼Œä¸å¯¹ï¼Œå› ä¸ºç»è¿‡è®¡ç®—ï¼Œåœ¨hashå‡½æ•°è®¾è®¡åˆç†çš„æƒ…å†µä¸‹ï¼Œå‘ç”Ÿhashç¢°æ’8æ¬¡çš„å‡ ç‡ä¸ºç™¾ä¸‡åˆ†ä¹‹6ï¼Œæ¦‚ç‡è¯´è¯ã€‚ã€‚å› ä¸º8å¤Ÿç”¨äº†ï¼Œè‡³äºä¸ºä»€ä¹ˆè½¬å›æ¥æ˜¯6ï¼Œå› ä¸ºå¦‚æœhashç¢°æ’æ¬¡æ•°åœ¨8é™„è¿‘å¾˜å¾Šï¼Œä¼šä¸€ç›´å‘ç”Ÿé“¾è¡¨å’Œçº¢é»‘æ ‘çš„è½¬åŒ–ï¼Œä¸ºäº†é¢„é˜²è¿™ç§æƒ…å†µçš„å‘ç”Ÿã€‚**é¢è¯•å®˜**:  HashMapå†…éƒ¨èŠ‚ç‚¹æ˜¯æœ‰åºçš„å—ï¼Ÿ**å®‰çªæ‹‰**:  æ˜¯æ— åºçš„ï¼Œæ ¹æ®hashå€¼éšæœºæ’å…¥**é¢è¯•å®˜**:  é‚£æœ‰æ²¡æœ‰æœ‰åºçš„Mapï¼Ÿ**å®‰çªæ‹‰**:  LinkedHashMap å’Œ TreeMap**é¢è¯•å®˜**:  è·Ÿæˆ‘è®²è®²LinkedHashMapæ€ä¹ˆå®ç°æœ‰åºçš„ï¼Ÿ**å®‰çªæ‹‰**:  LinkedHashMapå†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªå•é“¾è¡¨ï¼Œæœ‰å¤´å°¾èŠ‚ç‚¹ï¼ŒåŒæ—¶LinkedHashMapèŠ‚ç‚¹Entryå†…éƒ¨é™¤äº†ç»§æ‰¿HashMapçš„Nodeå±æ€§ï¼Œè¿˜æœ‰before å’Œ afterç”¨äºæ ‡è¯†å‰ç½®èŠ‚ç‚¹å’Œåç½®èŠ‚ç‚¹ã€‚å¯ä»¥å®ç°æŒ‰æ’å…¥çš„é¡ºåºæˆ–è®¿é—®é¡ºåºæ’åºã€‚

* * * * * * * * * * * * * * * * * * * * * * * * * * * 
```text
/** * The head (eldest) of the doubly linked list.*/transient LinkedHashMap.Entry head;
/**  * The tail (youngest) of the doubly linked list.*/transient LinkedHashMap.Entry tail;//é“¾æ¥æ–°åŠ å…¥çš„pèŠ‚ç‚¹åˆ°é“¾è¡¨åç«¯private void linkNodeLast(LinkedHashMap.Entry p) {  LinkedHashMap.Entry last = tail;  tail = p;  if (last == null)    head = p;  else {    p.before = last;    last.after = p;  }}//LinkedHashMapçš„èŠ‚ç‚¹ç±»static class Entry extends HashMap.Node {  Entry before, after;  Entry(int hash, K key, V value, Node next) {    super(hash, key, value, next);  }}
```

ç¤ºä¾‹ä»£ç ï¼š

* 
```text
public static void main(String[] args) {  Map map = new LinkedHashMap();  map.put("1", "å®‰çªæ‹‰");  map.put("2", "çš„");  map.put("3", "åšå®¢");  for(Map.Entry item: map.entrySet()){    System.out.println(item.getKey() + ":" + item.getValue());  }}//consoleè¾“å‡º1:å®‰çªæ‹‰2:çš„3:åšå®¢
```

**é¢è¯•å®˜**:  è·Ÿæˆ‘è®²è®²TreeMapæ€ä¹ˆå®ç°æœ‰åºçš„ï¼Ÿ**å®‰çªæ‹‰**ï¼šTreeMapæ˜¯æŒ‰ç…§Keyçš„è‡ªç„¶é¡ºåºæˆ–è€…Compratorçš„é¡ºåºè¿›è¡Œæ’åºï¼Œå†…éƒ¨æ˜¯é€šè¿‡çº¢é»‘æ ‘æ¥å®ç°ã€‚æ‰€ä»¥è¦ä¹ˆkeyæ‰€å±çš„ç±»å®ç°Comparableæ¥å£ï¼Œæˆ–è€…è‡ªå®šä¹‰ä¸€ä¸ªå®ç°äº†Comparatoræ¥å£çš„æ¯”è¾ƒå™¨ï¼Œä¼ ç»™TreeMapç”¨æˆ·keyçš„æ¯”è¾ƒã€‚**é¢è¯•å®˜**:  å‰é¢æåˆ°é€šè¿‡CAS å’Œ synchronizedç»“åˆå®ç°é”ç²’åº¦çš„é™ä½ï¼Œä½ èƒ½ç»™æˆ‘è®²è®²CAS çš„å®ç°ä»¥åŠsynchronizedçš„å®ç°åŸç†å—ï¼Ÿ**å®‰çªæ‹‰**:  ä¸‹ä¸€æœŸå’‹ä»¬å†çº¦æ—¶é—´ï¼ŒOKï¼Ÿ**é¢è¯•å®˜**:  å¥½å§ï¼Œå›å»ç­‰é€šçŸ¥å§ï¼

